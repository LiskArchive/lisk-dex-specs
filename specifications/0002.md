```
ID:     0002
Title:: Define liquidity provider interactions for DEX module
Author: Jan Hackfeld <jan.hackfeld@lightcurve.io>
Created: 2023-06-09
Updated: 2023-06-09
```

## Abstract

These specifications describe the internal functions, commands, APIs and endpoints related to liquidity provider interactions of the DEX module.

## Copyright

These specifications are licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

The motivation for this proposal is provided in the ["Define DEX module" specifications][define-dex-module].

## Rationale

The general rational for the DEX module is provided in the ["Define DEX module" specifications][define-dex-module]. In the following sections, we want to explain the rationale for the commands introduced in these specifications.

### Create-Pool Command

This command creates a new pool for a given pair of tokens and a fee tier together with an initial position for that pool.
The main reasons for including the creation of a first position with the pool creation is that it ensures that the blockchain in which the pool is created contains liquidity in both tokens of the pool.
Although the pool creator can immediately remove the position afterwards, it further incentives the pool creator to choose a meaningful initial price as otherwise other participants could immediately arbitrage after the pool creation.
Finally, the command includes a parameter `maxTimestampValid` to allow the command to time out which can be useful as the initial price will become outdated after a while.

### Create-Position Command

This commands allows to create a new position in an existing pool by providing the tick boundaries and a desired and minimum amount of tokens for each of the two tokens in the pool.
The lower and upper bound on each of the token amounts ensures that a liquidity provider only adds liquidity at an exchange rate similar to the one when issuing the command, thus protecting against slippage.
For instance, assume a liquidity provider adds a maximum of 100 `tokenA` and 200 `tokenB` over the full price range (the current price is 2 `tokenB` for 1 `tokenA`) with a minimum of 95 `tokenA` and 190 `tokenB`.
Then, in case there is a large swap just before the position creation changing the price to 1 `tokenB` for `tokenA`, the position creation will fail instead of the liquidity provider adding liquidity add an undesirable price.
This means that this mechanism in particular mitigates price manipulation with large swaps at the disadvantage of liquidity providers.
Finally, the command also includes a parameter `maxTimestampValid` to allow the command to time out which can be useful as the  price on which the minimum and maximum amounts of tokens are based will become outdated after a while.

### Add-Liquidity Command

This command allows to add liquidity to an existing position.
The input parameters are the same as for the create-position command except for that instead of the pool ID and tick boundaries, only the position ID is provided.
The rationale for the add-liquidity command is therefore also the same as for the create-position command as the same mechanism for slippage protection is used and it also uses the parameter `maxTimestampValid` for timeout.
Note that during the command execution, the collected fees are transferred to the position owner.
This has the advantage that it simplifies the state transition logic and additionally allows to collect and reinvest fees with just one command.

### Remove-Liquidity Command

This command allows to remove liquidity from an existing position by specifying the amount of liquidity to remove and the minimum amount of each token to remove as slippage protection.
For this command we use the liquidity instead of the desired amounts of each token to remove, as this allows to easily handle the case where the command issuer wants to remove all liquidity from a position.
If the desired amounts were used instead, it would be difficult to avoid that a negligible amount of liquidity is left in the position due to rounding.
Additionally, the command is more in line with the preferred user interactions on the front-end.
When removing liquidity, users would select the percentage of liquidity to remove instead of the maximum amounts for each token.
Similarly as for the case of adding liquidity, the parameter `maxTimestampValid` introduces a timeout which can be useful as the price on which the minimum amounts of tokens are based will become outdated after a while.

### Collect-Fees Command

This command allows to collect the accumulated fees for all the provided positions given that the command issuer is the position owner.
Note that when adding or removing liquidity the fees are already automatically transferred to the position owner.
This command is therefore added for convenience in case a liquidity provider wants to easily collect fees from multiple positions at once.

## Specification

### Constants

Most constants used in these specifications are defined in the section [Notation and Constants][define-dex-module-constants] of the "Define DEX module". The table below contains only some constants specific to these specifications.       

| Name                                       | Type     | Value  | Description                                         |
|--------------------------------------------|----------|--------|-----------------------------------------------------|
| **Return codes for events**                |        |                  |                            |                            
| `POOL_CREATION_SUCCESS`                    | `uint32` | 0      | Return code for successful pool creation.           |     
| `POOL_CREATION_FAILED_INVALID_FEE_TIER`    | `uint32` | 1      | Return code for failed pool creation due to an invalid fee tier in the pool creation. |     
| `POOL_CREATION_FAILED_ALREADY_EXISTS`      | `uint32` | 2      | Return code for failed pool creation due to an already existing pool. |
| `POSITION_CREATION_SUCCESS`                | `uint32` | 0      | Return code for successful position creation.       |     
| `POSITION_CREATION_FAILED_NO_POOL`         | `uint32` | 1      | Return code for failed position creation due to a non-existing pool. |     
| `POSITION_CREATION_FAILED_INVALID_TICK_SPACING` | `uint32` | 2   | Return code for failed position creation due to a invalid tick spacing. |
| `POSITION_CREATION_FAILED_INVALID_TICKS`   | `uint32` | 3   | Return code for failed position creation due to a invalid ticks. |          
| `POSITION_UPDATE_FAILED_NOT_EXISTS`        | `uint32` | 1      | Return code for failed position update as position does not exist. |
| `POSITION_UPDATE_FAILED_NOT_OWNER`         | `uint32` | 2      | Return code for failed position update as position owner is different from transaction sender. |
| `POSITION_UPDATE_FAILED_INSUFFICIENT_LIQUIDITY` | `uint32` | 3      | Return code for failed position update as transaction sender is not position owner. |


### Events

#### AmountBelowMin

This event is emitted whenever the computed amount added to a position is below the required minimum which makes a command fail.
The name of the event is `EVENT_NAME_AMOUNT_BELOW_MIN`.

##### Topics

* `senderAddress`: The address adding liquidity to the position.

##### Data

```java
amountBelowMinEventDataSchema = {
    "type": "object",
    "required": [
        "senderAddress",
        "amount0",
        "amount0Min",
        "tokenID0",
        "amount1",
        "amount1Min",
        "tokenID1"
    ],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "amount0": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "amount0Min": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
        "tokenID0": {
            "dataType": "bytes",
            "fieldNumber": 4
        },
        "amount1": {
            "dataType": "uint64",
            "fieldNumber": 5
        },
        "amount1Min": {
            "dataType": "uint64",
            "fieldNumber": 6
        },
        "tokenID1": {
            "dataType": "bytes",
            "fieldNumber": 7
        }
    }
}
```

#### FeesIncentivesCollected

This event is emitted whenever fees and incentives are collected by a position owner.
The name of the event is `EVENT_NAME_FEES_INCENTIVES_COLLECTED`.

##### Topics

* `senderAddress`: The address of the position owner.
* `positionID`: The ID of the position for which fees and incentives are collected.


##### Data

```java
feesIncentivesCollectedEventDataSchema = {
    "type": "object",
    "required": [
        "senderAddress",
        "positionID",
        "collectedFees0",
        "tokenID0",
        "collectedFees1",
        "tokenID1",
        "collectedIncentives",
        "tokenIDIncentives"
    ],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "positionID": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "collectedFees0": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
        "tokenID0": {
            "dataType": "bytes",
            "fieldNumber": 4
        },
        "collectedFees1": {
            "dataType": "uint64",
            "fieldNumber": 5
        },
        "tokenID1": {
            "dataType": "bytes",
            "fieldNumber": 6
        },
        "collectedIncentives": {
            "dataType": "uint64",
            "fieldNumber": 7
        },
        "tokenIDIncentives": {
            "dataType": "bytes",
            "fieldNumber": 8
        }
    }
}
```


#### PoolCreated

This event is emitted whenever a pool is successfully created.
The name of the event is `EVENT_NAME_POOL_CREATED`.

##### Topics

* `senderAddress`: The address of the transaction sender creating the pool.
* `poolID`: The ID of the newly created pool.


##### Data

```java
poolCreatedEventDataSchema = {
    "type": "object",
    "required":  ["senderAddress", "poolID", "tokenID0", "tokenID1", "feeTier"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "poolID": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "tokenID0": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "tokenID1": {
            "dataType": "bytes",
            "fieldNumber": 4
        },
        "feeTier": {
            "dataType": "uint32",
            "fieldNumber": 5
        }
    }
}
```

#### PoolCreationFailed

This event is emitted whenever the pool creation fails and it provides information about the failure reason.
The name of the event is `EVENT_NAME_POOL_CREATION_FAILED`.

##### Topics

* `senderAddress`: The address of the transaction sender attempting to create the pool.


##### Data

```java
poolCreationFailedEventDataSchema = {
    "type": "object",
    "required":  ["senderAddress", "tokenID0", "tokenID1", "feeTier", "result"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "tokenID0": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "tokenID1": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "feeTier": {
            "dataType": "uint32",
            "fieldNumber": 4
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 5
        }
    }
}
```

Note that `result` is an integer in `{POOL_CREATION_FAILED_INVALID_FEE_TIER, POOL_CREATION_FAILED_ALREADY_EXISTS}`.

#### PositionCreated

This event is emitted whenever a position is successfully created.
The name of the event is `EVENT_NAME_POSITION_CREATED`.

##### Topics

* `senderAddress`: The address of the transaction sender creating the position.
* `poolID`: The ID of the pool for which the position was created.
* `positionID`: The ID of the newly created position.

##### Data

```java
positionCreatedEventDataSchema = {
    "type": "object",
    "required": [
        "senderAddress",
        "positionID",
        "tickLower",
        "tickUpper",
        "amount0",
        "tokenID0",
        "amount1",
        "tokenID1"
    ],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "positionID": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "tickLower": {
            "dataType": "sint32",
            "fieldNumber": 2
        },
        "tickUpper": {
            "dataType": "sint32",
            "fieldNumber": 3
        },
        "amount0": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "tokenID0": {
            "dataType": "bytes",
            "fieldNumber": 5
        },
        "amount1": {
            "dataType": "uint64",
            "fieldNumber": 6
        },
        "tokenID1": {
            "dataType": "bytes",
            "fieldNumber": 7
        }
    }
}
```

#### PositionCreationFailed

This event is emitted whenever the position creation fails and it provides information about the failure reason.
The name of the event is `EVENT_NAME_POSITION_CREATION_FAILED`.

##### Topics

* `senderAddress`: The address of the transaction sender attempting to create the pool.

##### Data

```java
positionCreationFailedEventDataSchema = {
    "type": "object",
    "required": ["senderAddress", "poolID", "tickLower", "tickUpper", "result"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "poolID": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "tickLower": {
            "dataType": "sint32",
            "fieldNumber": 3
        },
        "tickUpper": {
            "dataType": "sint32",
            "fieldNumber": 4
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 5
        }
    }
}
```

Note that `result` is an integer in `{POSITION_CREATION_FAILED_NO_POOL, POSITION_CREATION_FAILED_INVALID_TICK_SPACING}`.

#### PositionUpdated

This event is emitted whenever a position is updated by adding or removing liquidity.
The name of the event is `EVENT_NAME_POSITION_UDPATED`.

##### Topics

* `senderAddres`: The address of the position owner adding or removing liquidity.
* `positionID`: The ID of the position for which the liquidity changed.

##### Data

```java
positionUpdatedEventDataSchema = {
    "type": "object",
    "required":  ["senderAddress", "positionID", "amount0", "tokenID0", "amount1", "tokenID1"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "positionID": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "amount0": {
            "dataType": "sint64",
            "fieldNumber": 3
        },
        "tokenID0": {
            "dataType": "bytes",
            "fieldNumber": 4
        },
        "amount1": {
            "dataType": "sint64",
            "fieldNumber": 5
        },
        "tokenID1": {
            "dataType": "bytes",
            "fieldNumber": 6
        }
    }
}
```

#### PositionUpdateFailed

This event is emitted whenever an update of a position fails.
The name of the event is `EVENT_NAME_POSITION_UDPATE_FAILED`.

##### Topics

* `senderAddress`: The address of the transaction sender attempting to update the position.
* `positionID`: The ID of the position for which the update failed.

##### Data

```java
positionUpdateFailedEventDataSchema = {
    "type": "object",
    "required": ["senderAddress", "positionID", "result"],
    "properties": {
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "positionID": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "result": {
            "dataType": "uint32",
            "fieldNumber": 3
        }
    }
}
```

Note that `result` is an integer in `{POSITION_UPDATE_FAILED_NOT_EXISTS, POSITION_UPDATE_FAILED_NOT_OWNER, POSITION_UPDATE_FAILED_INSUFFICIENT_LIQUIDITY}`.


### Commands

#### Create-Pool Command

The create-pool command allows to create a new pool for a pair of tokens and a given fee tier.
This command has command ID `COMMAND_ID_CREATE_POOL`.

##### Parameters

The `params` property of create-pool transactions follows the schema `createPoolSchema` defined below.

```java
createPoolSchema = {
    "type": "object",
    "required": [
        "tokenID0",
        "tokenID1",
        "feeTier",
        "tickInitialPrice",
        "initialPosition",
        "maxTimestampValid"
    ],
    "properties": {
        "tokenID0": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "tokenID1": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "feeTier": {
            "dataType": "uint32",
            "fieldNumber": 3
        },
        "tickInitialPrice": {
            "dataType": "sint32",
            "fieldNumber": 4
        },
        "initialPosition": {
            "type": "object",
            "fieldNumber": 5,
            "required": [
                "tickLower",
                "tickUpper",
                "amount0Desired",
                "amount1Desired"
            ],
            "properties": {
                "tickLower": {
                    "dataType": "sint32",
                    "fieldNumber": 1
                },
                "tickUpper": {
                    "dataType": "sint32",
                    "fieldNumber": 2
                },
                "amount0Desired": {
                    "dataType": "uint64",
                    "fieldNumber": 3
                },
                "amount1Desired": {
                    "dataType": "uint64",
                    "fieldNumber": 4
                }
            }
        },
        "maxTimestampValid": {
            "dataType": "uint64",
            "fieldNumber": 6
        }
    }
}
```

- `tokenID0`: The ID of one of the two tokens for which a pool is created.
- `tokenID1`: The ID of one of the two tokens for which a pool is created.
- `feeTier`: The fee tier of the pool that is to be created. Note that only the fee tiers given in the DEX global data store of the DEX module can be chosen.
- `tickInitialPrice`: The tick value corresponding to the initial sqrt price set for the pool.
- `initialPosition`: The initial position to be created together with the pool. Creating a pool always requires creating an initial position at the same time.
    - `tickLower`: The lower tick value of the position. Note that `tickLower % tickSpacing == 0` has to hold for the tick spacing corresponding to the fee tier of the pool.
    - `tickUpper`: The upper tick value of the position. Note that `tickUpper % tickSpacing == 0` has to hold for the tick spacing corresponding to the fee tier of the pool.
    - `amount0Desired`: The desired amount of `token0` to be added as liquidity to the position. The actual amount added as liquidity to the position will be at most `amount0Desired` and also depends on `tickInitialPrice`, `tickLower`, `tickUpper` and `amount1Desired`. The actual amount of `token0` added has to be positive, otherwise the command fails.
    - `amount1Desired`: The desired amount of `token1` to be added as liquidity to the position. The actual amount added as liquidity to the position will be at most `amount1Desired` and also depends on `tickInitialPrice`, `tickLower`, `tickUpper` and `amount0Desired`. The actual amount of `token1` added has to be positive, otherwise the command fails.
- `maxTimestampValid`: The timestamp of a block where a transaction with this command can be included.

##### Verification

```python
def verify(trs: Transaction) -> None:
    if trs.params does not satisfy createPoolSchema:
        raise Exception()
    if trs.params.tokenID0 >= trs.params.tokenID1 lexicographically:
        raise Exception()
    if trs.initialPosition.amount0Desired == 0 or trs.initialPosition.amount1Desired == 0:
        raise Exception()
    if MIN_TICK > trs.params.initialPosition.tickLower
       or trs.params.initialPosition.tickLower > trs.params.tickInitialPrice
       or trs.params.tickInitialPrice > trs.params.initialPosition.tickUpper
       or trs.params.initialPosition.tickLower >= trs.params.initialPosition.tickUpper
       or trs.params.initialPosition.tickUpper > MAX_TICK:
       raise Exception()
    if blockheader.timestamp > trs.params.maxTimestampValid:
        raise Exception()
    if computePoolID(tokenID0, tokenID1, feeTier) exists in Pools substore:
        raise Exception()
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    # create pool
    senderAddress = address derived from trs.senderPublicKey
    currentHeight = height of the block containing trs
    initialSqrtPrice = tickToPrice(trs.params.tickInitialPrice)
    result = createPool(trs.params.tokenID0, trs.params.tokenID1, trs.params.feeTier, initialSqrtPrice, currentHeight)
    if result != POOL_CREATION_SUCCESS:
        # the pool creation failed and an event indicating the failure reason is emitted
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_POOL_CREATION_FAILED,
            data = {
                "senderAddress": senderAddress,
                "tokenID0": tokenID0,
                "tokenID1": tokenID1,
                "feeTier": feeTier,
                "result": result
            },
            topics = [senderAddress]
        )
        raise Exception()

    poolID = computePoolID(trs.params.tokenID0, trs.params.tokenID1, trs.params.feeTier)
    # emit event about successful pool creation
    emitEvent(
        module = MODULE_NAME_DEX,
        name = EVENT_NAME_POOL_CREATED,
        data = {
            "senderAddress": senderAddress,
            "poolID": poolID,
            "tokenID0": trs.params.tokenID0,
            "tokenID1": trs.params.tokenID1,
            "feeTier":  trs.params.feeTier
        },
        topics = [
            senderAddress,
            poolID
        ]
    )

    # create initial position
    initialPosition = trs.params.initialPosition
    (result, positionID) = createPosition(senderAddress, poolID, initialPosition.tickLower, initialPosition.tickUpper)
    if result != POSITION_CREATION_SUCCESS:
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_POSITION_CREATION_FAILED,
            data = {
                "senderAddress": senderAddress,
                "poolID": poolID,
                "tickLower": initialPosition.tickLower,
                "tickUpper":  initialPosition.tickUpper,
                "result": result
            },
            topics = [senderAddress]
        )
        raise Exception()

    # add liquidity to position
    tickLowerSqrtPrice = tickToPrice(initialPosition.tickLower)
    tickUpperSqrtPrice = tickToPrice(initialPosition.tickUpper)
    liquidity = getLiquidityForAmounts(initialSqrtPrice,
                                       tickLowerSqrtPrice,
                                       tickUpperSqrtPrice,
                                       initialPosition.amount0Desired,
                                       initialPosition.amount1Desired)
    (amount0, amount1) = updatePosition(positionID, liquidity, currentHeight)

    # require liquidity to be added in both tokens
    if amount0 == 0 or amount1 == 0:
        # emit event explaining why the command execution failed
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_AMOUNT_BELOW_MIN,
            data = {
                "senderAddress": senderAddress,
                "amount0": amount0,
                "amount0Min": 1,
                "tokenID0": trs.params.tokenID0,
                "amount1": amount1,
                "amount1Min": 1,
                "tokenID1": trs.params.tokenID1,
            },
            topics = [senderAddress]
        )
        raise Exception()

    # this condition should actually never satisfied, but is added as precaution
    if amount0 > initialPosition.amount0Desired or amount1 > initialPosition.amount1Desired:
        raise Exception()

    # deduct pool creation fee
    Fee.payFee(POOL_CREATION_FEE)

    # emit event about the successful position creation detailing the exact amounts added to the position
    emitEvent(
        module = MODULE_NAME_DEX,
        name = EVENT_NAME_POSITION_CREATED,
        data = {
            "senderAddress": senderAddress,
            "positionID": positionID,
            "tickLower": initialPosition.tickLower,
            "tickUpper": initialPosition.tickUpper,
            "amount0": amount0,
            "tokenID0": trs.params.tokenID0,
            "amount1": amount1,
            "tokenID1": trs.params.tokenID1,
        },
        topics = [
            senderAddress,
            poolID,
            positionID
        ]
    )
```

#### Create-Position Command

This command lets a liquidity provider create a new position.
This command has command ID `COMMAND_ID_CREATE_POSITION`.

##### Parameters

```java
createPositionSchema = {
    "type": "object",
    "required": [
        "poolID",
        "tickLower",
        "tickUpper",
        "amount0Desired",
        "amount1Desired",
        "amount0Min",
        "amount1Min",
        "maxTimestampValid"
    ],
    "properties": {
        "poolID": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "tickLower": {
            "dataType": "sint32",
            "fieldNumber": 2
        },
        "tickUpper": {
            "dataType": "sint32",
            "fieldNumber": 3
        },
        "amount0Desired": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "amount1Desired": {
            "dataType": "uint64",
            "fieldNumber": 5
        },
        "amount0Min": {
            "dataType": "uint64",
            "fieldNumber": 6
        },
        "amount1Min": {
            "dataType": "uint64",
            "fieldNumber": 7
        },
        "maxTimestampValid": {
            "dataType": "uint64",
            "fieldNumber": 8
        }
    }
}
```

- `poolID`: The ID of the pool for which to create a new position.
- `tickLower`: The lower tick value of the position that is supposed to be created.
- `tickUpper`: The upper tick value of the position that is supposed to be created.
- `amount0Desired`: The desired amount of `token0` to be added as liquidity to the position. The actual amount `amount0` of `token0` added has to be at least `amount0Min` and at most `amount0Desired`, otherwise the command fails.
- `amount1Desired`: The desired amount of `token1` to be added as liquidity to the position. The actual amount `amount1` of `token1` added has to be at least `amount1Min` and at most `amount1Desired`, otherwise the command fails.
- `amount0Min`: The minimum amount of `token0` to be added as liquidity to the position.
- `amount1Min`: The minimum amount of `token1` to be added as liquidity to the position.
- `maxTimestampValid`: The timestamp of a block where a transaction with this command can be included.

##### Verification

```python
def verify(trs: Transaction) -> None:
    if trs.params does not satisfy createPositionSchema:
        raise Exception()
    if MIN_TICK > trs.params.tickLower
       or trs.params.tickLower >= trs.params.tickUpper
       or trs.params.tickUpper > MAX_TICK:
       raise Exception()
    if amount0Min > amount0Desired or amount1Min > amount1Desired:
        raise Exception()
    if blockheader.timestamp > trs.params.maxTimestampValid:
        raise Exception()
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    # create position
    senderAddress = address derived from trs.senderPublicKey
    (result, positionID) = createPosition(senderAddress, trs.params.poolID, trs.params.tickLower, trs.params.tickUpper)
    if result != POSITION_CREATION_SUCCESS:
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_POSITION_CREATION_FAILED,
            data = {
                "senderAddress": senderAddress,
                "poolID": trs.params.poolID,
                "tickLower": trs.params.tickLower,
                "tickUpper":  trs.params.tickUpper,
                "result": result
            },
            topics = [senderAddress]
        )
        raise Exception()

    # add liquidity to position                                
    currentHeight = height of the block containing trs
    currentSqrtPrice = bytesToQ96(pools[trs.params.poolID].sqrtPrice)
    tickLowerSqrtPrice = tickToPrice(trs.params.tickLower)
    tickUpperSqrtPrice = tickToPrice(trs.params.tickUpper)
    liquidity = getLiquidityForAmounts(currentSqrtPrice,
                                       tickLowerSqrtPrice,
                                       tickUpperSqrtPrice,
                                       trs.params.amount0Desired,
                                       trs.params.amount1Desired)
    (amount0, amount1) = updatePosition(positionID, liquidity, currentHeight)
    token0 = getToken0Id(trs.params.poolID)
    token1 = getToken1Id(trs.params.poolID)

    # check that amounts are within desired range (no large price slippage occurred)
    if amount0 < trs.params.amount0Min or amount1 < trs.params.amount1Min:
        # emit event explaining why the command execution failed
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_AMOUNT_BELOW_MIN,
            data = {
                "senderAddress": senderAddress,
                "amount0": amount0,
                "amount0Min": trs.params.amount0Min,
                "tokenID0": token0,
                "amount1": amount1,
                "amount1Min": trs.params.amount1Min,
                "tokenID1": token1,
            },
            topics = [senderAddress]
        )
        raise Exception()

    # this condition should actually never satisfied, but is added as precaution
    if amount0 > trs.params.amount0Desired or amount1 > trs.params.amount1Desired:
        raise Exception()

    # deduct position creation fee
    Fee.payFee(POSITION_CREATION_FEE)

    # emit event about the successful position creation detailing the exact amounts added to the position
    emitEvent(
        module = MODULE_NAME_DEX,
        name = EVENT_NAME_POSITION_CREATED,
        data = {
            "senderAddress": senderAddress,
            "positionID": positionID,
            "tickLower": trs.params.tickLower,
            "tickUpper":  trs.params.tickUpper,
            "amount0": amount0,
            "tokenID0": token0,
            "amount1": amount1,
            "tokenID1": token1,
        },
        topics = [
            senderAddress,
            poolID,
            positionID
        ]
    )
```

#### Add-Liquidity Command

This command lets a liquidity provider add liquidity to an existing position.
Additionally, all fees collected by the position are transferred to the liquidity provider account.
This command has command ID `COMMAND_ID_ADD_LIQUIDITY`.

##### Parameters

```java
addLiquiditySchema = {
    "type": "object",
    "required": [
        "positionID",
        "amount0Desired",
        "amount1Desired",
        "amount0Min",
        "amount1Min",
        "maxTimestampValid"
    ],
    "properties": {
        "positionID": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "amount0Desired": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "amount1Desired": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
        "amount0Min": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "amount1Min": {
            "dataType": "uint64",
            "fieldNumber": 5
        },
        "maxTimestampValid": {
            "dataType": "uint64",
            "fieldNumber": 6
        }
    }
}
```

- `positionID`: The ID of the position to which to add liquidity.
- `amount0Desired`: The desired amount of `token0` to be added as liquidity to the position. The actual amount `amount0` of `token0` added has to be at least `amount0Min` and at most `amount0Desired`, otherwise the command fails.
- `amount1Desired`: The desired amount of `token1` to be added as liquidity to the position. The actual amount `amount1` of `token1` added has to be at least `amount1Min` and at most `amount1Desired`, otherwise the command fails.
- `amount0Min`: The minimum amount of `token0` to be added as liquidity to the position.
- `amount1Min`: The minimum amount of `token1` to be added as liquidity to the position.
- `maxTimestampValid`: The timestamp of a block where a transaction with this command can be included.

##### Verification

```python
def verify(trs: Transaction) -> None:
    if trs.params does not satisfy addLiquiditySchema:
        raise Exception()
    if blockheader.timestamp > trs.params.maxTimestampValid:
        raise Exception()
    if amount0Min > amount0Desired or amount1Min > amount1Desired:
        raise Exception()
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    senderAddress = address derived from trs.senderPublicKey
    checkPositionExistenceAndOwnership(senderAddress, trs.params.positionID)

    # note that if a position exists, then a corresponding pool must exist
    poolID = getPoolIDFromPositionID(trs.params.positionID)
    currentSqrtPrice = bytesToQ96(pools[poolID].sqrtPrice)
    positionInfo = positions[positionID]
    tickLowerSqrtPrice = tickToPrice(positionInfo.tickLower)
    tickUpperSqrtPrice = tickToPrice(positionInfo.tickUpper)
    senderAddress = address derived from trs.senderPublicKey
    tokenID0 = getToken0Id(poolID)
    tokenID1 = getToken1Id(poolID)

    # add liquidity to position   
    currentHeight = height of the block containing trs
    liquidity = getLiquidityForAmounts(currentSqrtPrice,
                                       tickLowerSqrtPrice,
                                       tickUpperSqrtPrice,
                                       trs.params.amount0Desired,
                                       trs.params.amount1Desired)
    (amount0, amount1) = updatePosition(trs.params.positionID, liquidity, currentHeight)

    # check that amounts are within desired range (no large price slippage occurred)
    if amount0 < trs.params.amount0Min or amount1 < trs.params.amount1Min:
        # emit event explaining why the command execution failed
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_AMOUNT_BELOW_MIN,
            data = {
                "senderAddress": senderAddress,
                "amount0": amount0,
                "amount0Min": trs.params.amount0Min,
                "tokenID0": tokenID0,
                "amount1": amount1,
                "amount1Min": trs.params.amount1Min,
                "tokenID1": tokenID1,
            },
            topics = [senderAddress]
        )
        raise Exception()

    # this condition should actually never satisfied, but is added as precaution
    if amount0 > trs.params.amount0Desired or amount1 > trs.params.amount1Desired:
        raise Exception()

    # emit event detailing the exact amounts added to the position
    emitEvent(
        module = MODULE_NAME_DEX,
        name = EVENT_NAME_POSITION_UDPATED,
        data = {
            "senderAddress": senderAddress,
            "positionID": positionID,
            "amount0": amount0,
            "tokenID0": tokenID0,
            "amount1": amount1,
            "tokenID1": tokenID1,
        },
        topics = [
            senderAddress,
            positionID
        ]
    )
```

#### Remove-Liquidity Command

This command lets a liquidity provider remove liquidity from an existing position and, in particular, remove a position by removing all liquidity.
Additionally, all fees collected by the position are transferred to the liquidity provider account.
This command has command ID `COMMAND_ID_REMOVE_LIQUIDITY`.

##### Parameters

```java
removeLiquiditySchema = {
    "type": "object",
    "required": [
        "positionID",
        "liquidityToRemove",
        "amount0Min",
        "amount1Min",
        "maxTimestampValid"
    ],
    "properties": {
        "positionID": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "liquidityToRemove": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "amount0Min": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
        "amount1Min": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "maxTimestampValid": {
            "dataType": "uint64",
            "fieldNumber": 5
        }
    }
}
```

- `positionID`: The ID of the position from which to remove liquidity.
- `liquidityToRemove`: The amount of liquidity to be removed from the position. If all liquidity is removed from the position, then the position is deleted.
- `amount0Min`: The minimum amount of `token0` to be removed as liquidity from the position. The actual amount `amount0` of `token0` removed from the position has to be at least `amount0Min`, otherwise the command fails.
- `amount1Min`: The minimum amount of `token1` to be removed as liquidity from the position. The actual amount `amount1` of `token1` removed from the position has to be at least `amount1Min`, otherwise the command fails.
- `maxTimestampValid`: The timestamp of a block where a transaction with this command can be included.

##### Verification

```python
def verify(trs: Transaction) -> None:
    if trs.params does not satisfy removeLiquiditySchema:
        raise Exception()
    if blockheader.timestamp > trs.params.maxTimestampValid:
        raise Exception()
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    senderAddress = address derived from trs.senderPublicKey
    checkPositionExistenceAndOwnership(senderAddress, trs.params.positionID)
    currentHeight = height of the block containing trs
    (amount0, amount1) = updatePosition(trs.params.positionID, -trs.params.liquidityToRemove, currentHeight)
    poolID = getPoolIDFromPositionID(trs.params.positionID)
    tokenID0 = getToken0Id(poolID)
    tokenID1 = getToken1Id(poolID)

    if amount0 < trs.params.amount0Min or amount1 < trs.params.amount1Min:
        # emit event explaining why the command execution failed
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_AMOUNT_BELOW_MIN,
            data = {
                "senderAddress": senderAddress,
                "amount0": amount0,
                "amount0Min": trs.params.amount0Min,
                "tokenID0": tokenID0,
                "amount1": amount1,
                "amount1Min": trs.params.amount1Min,
                "tokenID1": tokenID1,
            },
            topics = [senderAddress]
        )
        raise Exception()

    # emit event detailing the exact amounts added to the position
    emitEvent(
        module = MODULE_NAME_DEX,
        name = EVENT_NAME_POSITION_UDPATED,
        data = {
            "senderAddress": senderAddress,
            "positionID": positionID,
            "amount0": -amount0,
            "tokenID0": tokenID0,
            "amount1": -amount1,
            "tokenID1": tokenID1,
        },
        topics = [
            senderAddress,
            positionID
        ]
    )
```

#### Collect-Fees Command

The collect-fees command allows to collect the fees for multiple positions.
This command has command ID `COMMAND_ID_COLLECT_FEES`.

##### Parameters

```java
collectFeesSchema = {
    "type": "object",
    "required": ["positions"],
    "properties": {
        "positions": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["positionID"],
                "properties": {
                    "positionID": {
                        "dataType": "bytes",
                        "fieldNumber": 1
                    }
                }
            }
        }
    }
}
```

- `positions`: An array of the position IDs for which to collect the fees.

##### Verification

```python
def verify(trs: Transaction) -> None:
    if trs.params does not satisfy collectFeesSchema:
        raise Exception()
    if len(trs.params.positions) > MAX_NUM_POSITIONS_FEE_COLLECTION:
        raise Exception()
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    senderAddress = address derived from trs.senderPublicKey
    currentHeight = height of the block containing trs
    for positionID in trs.params.positions
        checkPositionExistenceAndOwnership(senderAddress, positionID)
        collectFeesAndIncentives(positionID, currentHeight)
```

### Internal Functions

#### checkPositionExistenceAndOwnership

This function checks that the position with the provided position ID exists and that it belongs to the address `senderAddress`.
If this is not the case, a persistent event is emitted and an exception is raised.

```python
checkPositionExistenceAndOwnership(senderAddress: Address, positionID: PositionID) -> None:
    # check position existence
    if trs.params.positionID does not exist in Positions substore:
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_POSITION_UDPATE_FAILED,
            data = {
                "senderAddress": senderAddress,
                "positionID": positionID,
                "result": POSITION_UPDATE_FAILED_NOT_EXISTS
            },
            # note here the position ID is not added here on purpose so that the events related to the position
            # only relevant notifications about actions performed by the position owner
            topics = [senderAddress]
        )
        raise Exception()
    # check transaction sender is position owner
    if senderAddress != getOwnerAddressOfPosition(positionID):
        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_POSITION_UDPATE_FAILED,
            data = {
                "senderAddress": senderAddress,
                "positionID": positionID,
                "result": POSITION_UPDATE_FAILED_NOT_OWNER
            },
            # note here the position ID is not added here on purpose so that the events related to the position
            # only relevant notifications about actions performed by the position owner
            topics = [senderAddress]
        )
        raise Exception()
```


#### collectFeesAndIncentives

This function computes the share of fees and liquidity provider incentives earned by a position since the creation of the position or the last time the fees and incentives were collected.
Both fees and incentives are transferred to the position owner.

```python
def collectFeesAndIncentives(positionID: PositionID, currentHeight: uint32) -> None:
    poolID = getPoolIDFromPositionID(positionID)
    positionInfo = position(positionID)
    ownerAddress = getOwnerAddressOfPosition(positionID)
    # compute collectable fees
    (collectableFees0, collectableFees1, feeGrowthInside0, feeGrowthInside1) = computeCollectableFees(positionID)

    # transfer fees to position owner and update position accordingly
    if collectableFees0 > 0:
        transferFromPool(poolID, ownerAddress, getToken0Id(poolID), collectableFees0)
    if collectableFees1 > 0:
        transferFromPool(poolID, ownerAddress, getToken1Id(poolID), collectableFees1)
    positionInfo.feeGrowthInsideLast0 = q96ToBytes(feeGrowthInside0)
    positionInfo.feeGrowthInsideLast1 = q96ToBytes(feeGrowthInside1)

    # compute collectable incentives
    # update pool incentives at the current liquidity before withdrawing
    updatePoolIncentives(poolID, currentHeight)
    incentivesAccumulatorQ96 = bytesToQ96(pools[poolID].incentivesPerLiquidityAccumulator)
    (collectableIncentives, incentivesPerLiquidityInside) = computeCollectableIncentives(positionID, incentivesAccumulatorQ96)

    # transfer incentives and update position information accordingly
    Token.unlock(ADDRESS_LIQUIDITY_PROVIDER_INCENTIVES, MODULE_NAME_DEX, TOKEN_ID_INCENTIVES, collectableIncentives)
    Token.transfer(ADDRESS_LIQUIDITY_PROVIDER_INCENTIVES, ownerAddress, TOKEN_ID_INCENTIVES, collectableIncentives)
    positionInfo.incentivesPerLiquidityLast = q96ToBytes(incentivesPerLiquidityInside)
    position(positionID) = positionInfo

    # emit an event providing information about the collected fees and incentives
    emitEvent(
        module = MODULE_NAME_DEX,
        name = EVENT_NAME_FEES_INCENTIVES_COLLECTED,
        data = {
            "senderAddress": ownerAddress,
            "positionID": positionID,
            "collectedFees0": collectableFees0,
            "tokenID0": getToken0Id(poolID),
            "collectedFees1": collectableFees1,
            "tokenID1": getToken1Id(poolID),
            "collectedIncentives": collectableIncentives,
            "tokenIDIncentives": TOKEN_ID_INCENTIVES
        },
        topics = [
            ownerAddress,
            positionID
        ]
    )
```


#### computeCollectableFees

This function computes the fees that can be collected by the position owner.

##### Parameters

* `positionID`: The ID of the position for which to compute the fees that can be collected.

##### Returns

A tuple `(collectableFees0, collectableFees1, feeGrowthInside0, feeGrowthInside1)` where

 * `collectableFees0`: The amount of fees in `token0` that can be collected by the position owner.
 * `collectableFees1`: The amount of fees in `token1` that can be collected by the position owner.
 * `feeGrowthInside0`: The fee growth in terms of token0, per unit of liquidity, between the tick boundaries of the position.
 * `feeGrowthInside1`: The fee growth in terms of token1, per unit of liquidity, between the tick boundaries of the position.

##### Execution

```python
def computeCollectableFees(positionID: PositionID) -> Tuple[uint64, uint64, Q96, Q96]:
    # compute the accumulated fees per unit of liquidity
    positionInfo = position(positionID)
    poolID = getPoolIDFromPositionID(positionID)
    (feeGrowthInside0, feeGrowthInside1) = getFeeGrowthInside(positionID)

    # calculate collected fees
    # note that collectableFees0 and collectableFees1 are uint64 integers and the collected fees may be smaller
    # than the smallest token unit and therefore be rounded down to 0
    collectableFees0 = roundDown_96(mul_96(sub_96(feeGrowthInside0, bytesToQ96(positionInfo.feeGrowthInsideLast0)), Q96(positionInfo.liquidity)))
    collectableFees1 = roundDown_96(mul_96(sub_96(feeGrowthInside1, bytesToQ96(positionInfo.feeGrowthInsideLast1)), Q96(positionInfo.liquidity)))

    return (collectableFees0, collectableFees1, feeGrowthInside0, feeGrowthInside1)
```


#### computeCollectableIncentives

Given a position, this function computes the additional liquidity provider incentives for the position owner. The function allows to compute incentives for a particular value of incentives per liquidity accumulator in the pool containing the given position.

##### Parameters

* `positionID`: The ID of the position for which to collect the fees.
* `incentivesPerLiquidityAccumulator`: The Q96 value of incentives per liquidity accumulator in the pool containing the position.

##### Returns

A tuple `(collectableIncentives, incentivesPerLiquidityInside)` where

* `collectableIncentives`: The amount of liquidity provider incentives to be collected in `TOKEN_ID_INCENTIVES`.
* `incentivesPerLiquidityInside`: The current position incentives given per unit of liquidity.

##### Execution

```python
def computeCollectableIncentives(positionID: PositionID, incentivesPerLiquidityAccumulator: Q96) -> Tuple[uint64, Q96]:
    positionInfo = positions[positionID]
    poolID = getPoolIDFromPositionID(positionID)

    poolInfo = pools[poolID]
    tickLower = positionInfo.tickLower
    tickUpper = positionInfo.tickUpper
    tickCurrent = priceToTick(bytesToQ96(poolInfo.sqrtPrice))
    lowerTickInfo = ticks(poolID, tickLower)
    upperTickInfo = ticks(poolID, tickUpper)

    # compute incentives per liquidity below
    if tickCurrent >= tickLower:
        incentivesPLBelow = bytesToQ96(lowerTickInfo.incentivesPerLiquidityOutside)
    else:
        incentivesPLBelow = sub_96(incentivesPerLiquidityAccumulator, bytesToQ96(lowerTickInfo.incentivesPerLiquidityOutside))
    # compute incentives per liquidity above
    if tickCurrent < tickUpper:
        incentivesPLAbove = bytesToQ96(upperTickInfo.incentivesPerLiquidityOutside)
    else:
        incentivesPLAbove = sub_96(incentivesPerLiquidityAccumulator, bytesToQ96(upperTickInfo.incentivesPerLiquidityOutside))

    incentivesPerLiquidityInside = sub_96(sub_96(incentivesPerLiquidityAccumulator, incentivesPLBelow), incentivesPLAbove)
    collectableIncentivesPL = sub_96(incentivesPerLiquidityInside, bytesToQ96(positionInfo.incentivesPerLiquidityLast))
    collectableIncentives = roundDown_96(mul_96(collectableIncentivesPL, Q96(positionInfo.liquidity)))
    return (collectableIncentives, incentivesPerLiquidityInside)
```


#### computePoolID

This function computes the pool ID from the two token IDs `tokenID0` and `tokenID1` of the tokens in the pool as well as the fee tier `feeTier` of the pool.

```python
computePoolID(tokenID0: TokenID, tokenID1: TokenID, feeTier: uint32) -> PoolID:
    return tokenID0 + tokenID1 + feeTier.to_bytes(4, byteorder = 'big')
```


#### createPool

This internal function is used to create a new liquidity pool with the provided parameters.

##### Parameters

* `tokenID0`: The token ID of the first token in the pool.
* `tokenID1`: The token ID of the second token in the pool.
* `feeTier`: The fee tier of the pool.
* `initialSqrtPrice`: The square root of the initial price of the pool.

##### Returns

* An integer indicating whether the pool was created successfully (value `POOL_CREATION_SUCCESS`) or the type of failure in the pool creation.

##### Execution

```python
def createPool(tokenID0: TokenID, tokenID1: TokenID, feeTier: uint32, initialSqrtPrice: Q96, currentHeight: uint32) -> uint32:
    # check validity of input parameters
    if there is no entry s in dexGlobalData.poolCreationSettings with s.feeTier == feeTier:
        return POOL_CREATION_FAILED_INVALID_FEE_TIER
    poolSetting = entry s in dexGlobalData.poolCreationSettings with s.feeTier == feeTier

    poolID = computePoolID(tokenID0, tokenID1, feeTier)
    # check if pool already exists
    if poolID in Pools Substore:
        return POOL_CREATION_FAILED_ALREADY_EXISTS

    poolStoreValue = {
        "liquidity": 0,
        "sqrtPrice": initialSqrtPrice,
        "incentivesPerLiquidityAccumulator": q96ToBytes(Q96(0)),
        "heightIncentivesUpdate": currentHeight,
        "feeGrowthGlobal0": q96ToBytes(Q96(0)),
        "feeGrowthGlobal1": q96ToBytes(Q96(0)),
        "tickSpacing": poolSetting.tickSpacing
    }
    pools[poolID] = encode(poolsSchema, poolStoreValue)
    return POOL_CREATION_SUCCESS
```


#### createPosition

This function creates a new position in an existing pool.

##### Parameters

* `senderAddress`: The address of the pool creator as byte array of length `NUM_BYTES_ADDRESS`.
* `poolID`: The pool ID value of an existing pool to which the position is added. The pool ID is a byte array of length `NUM_BYTES_POOL_ID`.
* `tickLower`: The lower tick of the new position as integer in the `sint32` range.
* `tickUpper`: The upper tick of the new position as integer in the `sint32` range.

##### Returns

The function returns a tuple `(result, positionID)` where:

* `result`: An integer indicating the successful position creation (`result == POSITION_CREATION_SUCCESS`) or the reason why the position creation failed (`result != POSITION_CREATION_SUCCESS`).
* `positionID`: If `result == POSITION_CREATION_SUCCESS`, then this is the position ID of the newly created position.

##### Execution

```python
def createPosition(senderAddress: Address, poolID: PoolID, tickLower: uint32, tickUpper: uint32) -> Tuple[uint32, PositionID]:
    # check that the corresponding pool is initialized
    if not poolID in Pools Substore:
        return (POSITION_CREATION_FAILED_NO_POOL, b'')
    currentPool = pools[poolID]

    # Check that tickLower < tickUpper and ticks are within global bounds.
    # Currently this is redundant as it is already guaranteed by commands defined in these specifications,
    # but could be useful if this function becomes accessible via an API in the future.
    if MIN_TICK > tickLower
       or tickLower>= tickUpper
       or tickUpper > MAX_TICK:
       return (POSITION_CREATION_FAILED_INVALID_TICKS, b'')
    # check that only ticks according to the pools tick spacing are initialized
    if tickLower % currentPool.tickSpacing != 0 or tickUpper % currentPool.tickSpacing != 0:
        return (POSITION_CREATION_FAILED_INVALID_TICK_SPACING, b'')

    # check if the lower price tick entry exist and update/create it
    if ticks(poolID, tickLower) does not exist:
        tickStoreValue = {
           "liquidityNet": 0,
           "liquidityGross": 0,
           "feeGrowthOutside0": q96ToBytes(Q96(0)),
           "feeGrowthOutside1": q96ToBytes(Q96(0)),
           "incentivesPerLiquidityOutside": q96ToBytes(Q96(0))
        }
        if bytesToQ96(currentPool.sqrtPrice) >= tickToPrice(tickLower):
            tickStoreValue.feeGrowthOutside0 = currentPool.feeGrowthGlobal0
            tickStoreValue.feeGrowthOutside1 = currentPool.feeGrowthGlobal1
            tickStoreValue.incentivesPerLiquidityOutside = currentPool.incentivesPerLiquidityAccumulator

        ticks(poolID, tickLower) = encode(priceTickSchema, tickStoreValue)

    # check if the upper price tick entry exist and update/create it
    if ticks(poolID, tickUpper) does not exist:
        tickStoreValue = {
            "liquidityNet": 0,
            "liquidityGross": 0,
            "feeGrowthOutside0": q96ToBytes(Q96(0)),
            "feeGrowthOutside1": q96ToBytes(Q96(0)),
            "incentivesPerLiquidityOutside": q96ToBytes(Q96(0))
        }
        if bytesToQ96(currentPool.sqrtPrice) >= tickToPrice(tickUpper):
            tickStoreValue.feeGrowthOutside0 = currentPool.feeGrowthGlobal0
            tickStoreValue.feeGrowthOutside1 = currentPool.feeGrowthGlobal1
            tickStoreValue.incentivesPerLiquidityOutside = currentPool.incentivesPerLiquidityAccumulator

        ticks(poolID, tickUpper) = encode(priceTickSchema, tickStoreValue)

    positionID = getNewPositionID(poolID, senderAddress)  

    positionValue = {
        "tickLower": tickLower,
        "tickUpper": tickUpper,
        "liquidity": 0,
        "feeGrowthInsideLast0": q96ToBytes(Q96(0)),
        "feeGrowthInsideLast1": q96ToBytes(Q96(0)),
        "ownerAddress": senderAddress,
        "incentivesPerLiquidityLast": q96ToBytes(Q96(0))
    }
    positions[positionID] = encode(positionSchema, positionValue)
    return (POSITION_CREATION_SUCCESS, positionID)
```


#### getFeeGrowthInside

This function allows to compute the fee growth inside a position and corresponds to [the following function in Uniswap](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Tick.sol#L60).

##### Parameters

- `positionID`: The ID of the position for which to compute the fee growth.

##### Returns

- `feeGrowthInside0`: The fee growth in terms of token0, per unit of liquidity, between the tick boundaries of the position.
- `feeGrowthInside1`: The fee growth in terms of token1, per unit of liquidity, between the tick boundaries of the position.

##### Execution

```python
def getFeeGrowthInside(positionID: PositionID) -> Tuple[Q96, Q96]:
    positionInfo = positions[positionID]
    poolID = getPoolIDFromPositionID(positionID)
    poolInfo = pools[poolID]

    tickLower = positionInfo.tickLower
    tickUpper = positionInfo.tickUpper
    tickCurrent = priceToTick(bytesToQ96(poolInfo.sqrtPrice))
    lowerTickInfo = ticks(poolID, tickLower)
    upperTickInfo = ticks(poolID, tickUpper)

    # compute the fee growth below
    if tickCurrent >= tickLower:
        feeGrowthBelow0 = bytesToQ96(lowerTickInfo.feeGrowthOutside0)
        feeGrowthBelow1 = bytesToQ96(lowerTickInfo.feeGrowthOutside1)
    else:
        feeGrowthBelow0 = sub_96(bytesToQ96(poolInfo.feeGrowthGlobal0), bytesToQ96(lowerTickInfo.feeGrowthOutside0))
        feeGrowthBelow1 = sub_96(bytesToQ96(poolInfo.feeGrowthGlobal1), bytesToQ96(lowerTickInfo.feeGrowthOutside1))

    # compute the fee growth above
    if tickCurrent < tickUpper:
        feeGrowthAbove0 = bytesToQ96(upperTickInfo.feeGrowthOutside0)
        feeGrowthAbove1 = bytesToQ96(upperTickInfo.feeGrowthOutside1)
    else:
        feeGrowthAbove0 = sub_96(bytesToQ96(poolInfo.feeGrowthGlobal0), bytesToQ96(upperTickInfo.feeGrowthOutside0))
        feeGrowthAbove1 = sub_96(bytesToQ96(poolInfo.feeGrowthGlobal1), bytesToQ96(upperTickInfo.feeGrowthOutside1))

    feeGrowthInside0 = sub_96(sub_96(bytesToQ96(poolInfo.feeGrowthGlobal0), feeGrowthBelow0), feeGrowthAbove0)
    feeGrowthInside1 = sub_96(sub_96(bytesToQ96(poolInfo.feeGrowthGlobal1), feeGrowthBelow1), feeGrowthAbove1)
    return (feeGrowthInside0, feeGrowthInside1)
```


#### getLiquidityForAmounts

This function computes the maximum liquidity that can be added by a position which is sending a certain amount of tokens. This function is similar to the function [getLiquidityForAmounts](https://github.com/Uniswap/v3-periphery/blob/51f8871aaef2263c8e8bbf4f3410880b6162cdea/contracts/libraries/LiquidityAmounts.sol#L56) in Uniswap v3 and the function [maxLiquidityForAmounts](https://github.com/Uniswap/v3-sdk/blob/218eec99a1e6470e1a42fba4eab92b3ff9d02964/src/utils/maxLiquidityForAmounts.ts#L68) in the Uniswap v3 SDK.

##### Parameters

- `currentSqrtPrice`: The sqrt price of the pool as Q96 number.
- `lowerTickSqrtPrice`: The sqrt price of the lower tick of the position as `Q96` number.
- `upperTickSqrtPrice`: The sqrt price of the upper tick of the position as `Q96` number.
- `amount0`: The amount of `token0` sent as `uint64`.
- `amount1`: The amount of `token1` sent as `uint64`.

##### Returns

The function returns the maximum liquidity as `uint64` that can be added by a position with the given parameters.

##### Execution

```python
def getLiquidityForAmounts(currentSqrtPrice: Q96,
                           lowerTickSqrtPrice: Q96,
                           upperTickSqrtPrice: Q96,
                           amount0: uint64,
                           amount1: uint64) -> uint64:
    if lowerTickSqrtPrice > upperTickSqrtPrice:
        raise Exception()

    if currentSqrtPrice <= lowerTickSqrtPrice:
        liquidity = getLiquidityForAmount0(lowerTickSqrtPrice, upperTickSqrtPrice, amount0)
    elif currentSqrtPrice < upperTickSqrtPrice:
        liquidity0 = getLiquidityForAmount0(currentSqrtPrice, upperTickSqrtPrice, amount0)
        liquidity1 = getLiquidityForAmount1(lowerTickSqrtPrice, currentSqrtPrice, amount1)

        if liquidity0 < liquidity1:
            liquidity = liquidity0
        else:
            liquidity = liquidity1
    else:
        liquidity = getLiquidityForAmount1(lowerTickSqrtPrice, upperTickSqrtPrice, amount1)

    if liquidity < 0 or liquidity >= 2**64:
        raise Exception()
    return liquidity

# see Equation (4) in http://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf
def getLiquidityForAmount0(lowerSqrtPrice: Q96, upperSqrtPrice: Q96, amount0: uint64) -> uint64:
    intermediate = mul_96(lowerSqrtPrice, upperSqrtPrice)
    result = muldiv_96(Q96(amount0), intermediate, sub_96(upperSqrtPrice, lowerSqrtPrice))
    return roundDown_96(result)

# see Equation (9) in http://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf
def getLiquidityForAmount1(lowerSqrtPrice, upperSqrtPrice, amount1):
    result = div_96(Q96(amount1), sub_96(upperSqrtPrice, lowerSqrtPrice))
    return roundDown_96(result)
```


#### getNewPositionID

This function allows to get the position ID of a newly created position.

```python
getNewPositionID(poolID: PoolID, ownerAddress: Address) -> PositionID:
    positionIndex = dexGlobalData.positionCounter
    dexGlobalData.positionCounter = dexGlobalData.positionCounter +1

    #nftID = NFT.create(senderAddress, NFT_COLLECTION_DEX, empty byte array)
    #positionID = poolID || uint64be(nftID.index)
    #NFT.setAttributes(positionID, nftID)

    return poolID + positionIndex.to_bytes(8, byteorder = 'big')
```


#### getOwnerAddressOfPosition

This function allows to get the address of the owner of the position provided as input.

```python
getOwnerAddressOfPosition(positionID: PositionID) -> Address:
    return position(positionID).ownerAddress
```


#### updatePosition

This function updates or deletes an existing entry in the positions substore.
It also updates the corresponding price ticks and deletes them if necessary.
It also updates the `pools.liquidity` property of the pool if `pools.sqrtPrice` is within the range of the updated position.
It always transfers the collected fees to the position owner.
Additionally, if the function is subtracting liquidity, the respective token amounts are transferred to the position owner.
The function is similar to the function [_modifyPosition](https://github.com/Uniswap/v3-core/blob/ed88be38ab2032d82bf10ac6f8d03aa631889d48/contracts/UniswapV3Pool.sol#L306) in Uniswap v3.

##### Parameters

* `positionID`: The ID of the position that is supposed to be updated.
* `liquidityDelta`: The change of liquidity, i.e., a positive integer if liquidity is added and a negative integer if liquidity is supposed to be removed.
* `currentHeight`: An integer with the height of the block when the swap is performed, is needed for correct incentive computation.


##### Returns

The function returns `(amount0, amount1)`, where `amount0` for `liquidityDelta >= 0` is the amount of `token0` added to the position and for `liquidityDelta < 0` the amount of `token0` removed from the position.
Analogously, `amount1` is the amount of `token1` added or removed from the position.

##### Execution

```python
def updatePosition(positionID: PositionID, liquidityDelta: int64, currentHeight: uint32) -> Tuple[uint64, uint64]:
    # check validity of input parameters
    positionInfo = positions[positionID]
    if -liquidityDelta > positionInfo.liquidity:
        # this can only occur if the removed liquidity is larger than the liquidity of the position
        ownerAddress = getOwnerAddressOfPosition(positionID)

        emitPersistentEvent(
            module = MODULE_NAME_DEX,
            name = EVENT_NAME_POSITION_UDPATE_FAILED,
            data = {
                "senderAddress": ownerAddress,
                "positionID": positionID,
                "result": POSITION_UPDATE_FAILED_INSUFFICIENT_LIQUIDITY
            },
            topics = [ownerAddress, positionID]
        )
        raise Exception()

    # collect the fees and update the position accordingly
    collectFeesAndIncentives(positionID, currentHeight)

    # check that we are actually updating the position not only collecting fees
    if liquidityDelta == 0:
        amount0 = 0
        amount1 = 0
        return (amount0, amount1)

    # calculate output amounts
    poolID = getPoolIDFromPositionID(positionID)
    poolInfo = pools[poolID]
    lowerTickInfo = ticks(poolID, positionInfo.tickLower)
    upperTickInfo = ticks(poolID, positionInfo.tickUpper)
    sqrtPriceLow = tickToPrice(positionInfo.tickLower)
    sqrtPriceUp = tickToPrice(positionInfo.tickUpper)
    sqrtPrice = bytesToQ96(poolInfo.sqrtPrice)

    # if liquidity is added, we need to round up so that we ensure that at least the required amount of token is added
    # if liquidity is removed, we need to round down so that we ensure that at most the required amount of token is removed
    roundUp = liquidityDelta > 0

    if sqrtPrice <= sqrtPriceLow:
        amount0 = getAmount0Delta(sqrtPriceLow, sqrtPriceUp, abs(liquidityDelta), roundUp)
        amount1 = 0
    elif sqrtPriceLow < sqrtPrice and  sqrtPrice < sqrtPriceUp:
        amount0 = getAmount0Delta(sqrtPrice, sqrtPriceUp, abs(liquidityDelta), roundUp)
        amount1 = getAmount1Delta(sqrtPriceLow, sqrtPrice, abs(liquidityDelta), roundUp)
    else: # sqrtPriceUp < poolInfo.sqrtPrice
        amount0 = 0
        amount1 = getAmount1Delta(sqrtPriceLow, sqrtPriceUp, abs(liquidityDelta), roundUp)

    # transfer the respective amounts to the pool or from the pool
    ownerAddress = getOwnerAddressOfPosition(positionID)
    if liquidityDelta > 0:
        transferToPool(ownerAddress, poolID, getToken0Id(poolID), amount0)
        transferToPool(ownerAddress, poolID, getToken1Id(poolID), amount1)
    else:
        transferFromPool(poolID, ownerAddress, getToken0Id(poolID), amount0)
        transferFromPool(poolID, ownerAddress, getToken1Id(poolID), amount1)

    # update the pool entry if sqrtPrice is in the price range
    if sqrtPriceLow <= sqrtPrice and sqrtPrice < sqrtPriceUp:
        poolInfo.liquidity += liquidityDelta
        pools[poolID] = poolInfo

    # update position liquidity
    positionInfo.liquidity += liquidityDelta
    if positionInfo.liquidity == 0:
        delete entry positions[positionID]
    else:
        positions[positionID] = positionInfo

    # update price ticks
    lowerTickInfo.liquidityNet += liquidityDelta
    upperTickInfo.liquidityNet -= liquidityDelta
    lowerTickInfo.liquidityGross += liquidityDelta
    upperTickInfo.liquidityGross += liquidityDelta

    if lowerTickInfo.liquidityGross == 0:
        delete entry ticks(poolID,  positionInfo.tickLower)
    else:
        ticks(poolID, positionInfo.tickLower) = lowerTickInfo

    if upperTickInfo.liquidityGross == 0:
        delete entry ticks(poolID,  positionInfo.tickUpper)
    else:
        ticks(poolID, positionInfo.tickUpper) = upperTickInfo

    return (amount0, amount1)
```

### Protocol Logic for Other Modules

TBD

### Endpoints for Off-Chain Services

#### getCollectableFees

This endpoints allows to obtain the amount of fees that can be collected for a given position.

##### Parameters

- `positionID`: The ID of the position for which to get the collectable fees.

##### Returns

A tuple `(collectableFees0, collectableFees1, collectableIncentives)` where

* `collectableFees0`: The amount of fees in `token0` that can be collected by the position owner.
* `collectableFees1`: The amount of fees in `token1` that can be collected by the position owner.
* `collectableIncentives`: The amount of liqudity provider incentives in the token with ID `TOKEN_ID_INCENTIVES` that can be collected by the position owner.

##### Execution

```python
getCollectableFeesAndIncentives(positionID: PositionID) -> Tuple[uint64, uint64, uint64]:
    # check validity of input parameters
    if positionID not in positions:
       raise Exception()

    (collectableFees0, collectableFees1, feeGrowthInside0, feeGrowthInside1) = computeCollectableFees(positionID)

    poolID = getPoolIDFromPositionID(positionID)
    height = current height of the last block
    updatedIncentivesPerLiqiudity = computeNewIncentivesPerLiquidity(poolID, height)
    (collectableIncentives, incentivesPerLiquidityInside) = computeCollectableIncentives(positionID, updatedIncentivesPerLiqiudity)
    return (collectableFees0, collectableFees1, collectableIncentives)
```

## Backwards Compatibility

These specifications, together with the ["Introduce DEX Module" specifications][define-dex-module] and ["Define swap interaction for DEX module" specifications][define-swap-interactions], introduce a new module with its dedicated module store and commands. Adding this module to an existing blockchain therefore requires a hardfork.

## Reference Implementation

TBD

## Appendix

### User Flow for Commands

This section contains recommendation of how the parameters for the different commands defined in these specifications can be prepared.
In particular, we describe which command parameters should be requested from the user and how the other parameters can be computed.

#### Global User Interface Settings

We assume the following values can be set by the user as global settings in the user interfaces and do not have to be requested for every interaction (e.g., position creation or update).
The settings can be initialized with some default values as suggested:

- `slippageTolerance`: Slippages here refers to the potential difference in price between the time the transaction is signed by a user and the time the transaction is processed by the blockchain. The value `slippageTolerance` is an integer describing the maximum acceptable slippage to the user in parts-per-million. For instance, `slippageTolerance = 3000` means that the price is allowed to change by at most 0.3 %. We recommend to use `slippageTolerance = 5000` as an initial default for the user interfaces and adjust it according to the observed slippage in practice. Ideally, the value is chosen high enough such that in the vast majority of cases commands are executed successful, but low enough that users do not suffer from worse prices due to price manipulations or sandwich-attacks, for instance.
- `transactionValidityInSeconds`: This value determines how long a transaction that is submitted via the user interfaces is valid. Note that in the user interface it may be better to show the equivalent number of minutes instead. We recommend using an initial value of `transactionValidityInSeconds = 15 * 60`. For any command with a property `maxTimestampValid`, the user interfaces should then set `maxTimestampValid = currentTime + transactionValidityInSeconds` where `currentTime` is the current timestamp in seconds (as used in the Lisk blockchain for timestamps in blocks).

#### Creating a New Position

When creating a new position, a user first selects the following:

- `tokenIDInput0`: The token ID of the first token in the pool. Here by default the `LSK` token could be chosen.
- `tokenIDInput1`: The token ID of the second token in the pool.
- `feeTier`: The fee tier of the pool. Here by default the most common fee tier (e.g., 0.3 %) could be selected.

If `tokenIDInput0 < tokenIDInput1`, we let `tokenID0 = tokenIDInput0` and `tokenID1 = tokenIDInput1` in the following sections, otherwise we assume `tokenID0 = tokenIDInput1` and `tokenID1 = tokenIDInput0`. Let further `poolID = computePoolID(tokenID0, tokenID1, feeTier)`.

**Case 1**: A pool with ID `poolID` does not exist in the Pools substore.

In this case, the following steps are needed:

1. The user is informed that the pool needs to be created and that this implies a fee given by `POOL_CREATION_FEE`.
2. The user has to provide a starting price `startingPriceInput`. The UI computes `(tickInitialPrice, startingPriceOutput) = computeTickAndPriceRoundedToTick(startingPrice)`. It is recommended that the user interface shows the rounded starting price `startingPriceOutput` so that the user is aware of the actual starting price that would be used in the command.
3. The user chooses the range for the position by selection a lower bound `priceInputLower` and an upper bound `priceInputUpper`. The UI computes:
   - `(tickLower, priceOutputLower) = computeTickAndPriceRoundedToTick(priceInputLower)`,
   - `(tickUpper, priceOutputUpper) = computeTickAndPriceRoundedToTick(priceInputUpper)`.
  Again it is recommended that the user interface shows the rounded prices `priceOutputLower` and `priceOutputUpper` so that the user is aware of the actual lower and upper bound for the position that would be used in the command.
4. The user now can choose the desired amounts of tokens for the position. These depend on the starting price as well as lower and upper price previously provided by the user as follows:
   - `tickInitialPrice <=  tickLower`: The user can only provide an amount in `token1`. Let `inputAmount0 = 0` and `inputAmount1` be the input amount of `token1` provided by the user.
   - `tickLower < tickInitialPrice <  tickUpper`: The user has to provide both `token0` and `token1`. If the user enters `inputAmount0` as the amount of `token0`, then `inputAmount1 = computeAmount1ForPosition(tickLower, tickUpper, tickToPrice(tickInitialPrice), inputAmount0)` is computed and displayed as the amount of `token1`. Similarly, if the user enters `inputAmount1` as the amount of `token1`, then `inputAmount0 = computeAmount0ForPosition(tickLower, tickUpper, tickToPrice(tickInitialPrice), inputAmount1)` is computed and displayed as the amount of `token0`.
   - `tickUpper <=  tickInitialPrice`: The user can only provide an amount in `token0`. Let `inputAmount1 = 0` and `inputAmount0` be the input amount of `token0` provided by the user.

Once the user has provided the data as described above, the create-pool is prepared with the following parameters:

- "tokenID0": `tokenID0`
- "tokenID1": `tokenID1`
- "feeTier": `feeTier`
- "tickInitialPrice": `tickInitialPrice`
- "initialPosition"
  - "tickLower": `tickLower`
  - "tickUpper": `tickUpper`
  - "amount0Desired": `inputAmount0`
  - "amount1Desired": `inputAmount1`
- "maxTimestampValid": `maxTimestampValid` as described in the global user settings

**Case 2**: A pool with ID `poolID` exists in the Pools substore.

In this case, the following steps are needed:

1. The user selects the price range for the position as in Step 3 of Case 1 above. The current distribution of liquidity and the current price can be useful information shown to the user in this step.
2. The user now can choose the desired amounts of tokens for the position. Let `sqrtCurrentPrice = getCurrentSqrtPrice(poolID, True)` be the current price in the pool. Then the amounts depend on the current price as well as lower and upper price previously provided by the user as follows:
    - `sqrtCurrentPrice <=  priceToTick(tickLower)`: The user can only provide an amount in `token1`.
        - `inputAmount0 = 0`,
        - `inputAmount1 =` input amount of `token1` provided by the user.
    - `priceToTick(tickLower) < tickInitialPrice <  priceToTick(tickUpper)`: The user has to provide both `token0` and `token1`.
        - If the user enters `inputAmount0` as the amount of `token0`, then `inputAmount1 = computeAmount1ForPosition(tickLower, tickUpper, sqrtCurrentPrice, inputAmount0)` is computed and displayed as the amount of `token1`.
        - Similarly, if the user enters `inputAmount1` as the amount of `token1`, then `inputAmount0 = computeAmount0ForPosition(tickLower, tickUpper, sqrtCurrentPrice, inputAmount1)` is computed and displayed as the amount of `token0`.
   - `priceToTick(tickUpper) <=  sqrtCurrentPrice`: The user can only provide an amount in `token0`.
       - `inputAmount1 = 0`,
       - `inputAmount0 =` input amount of `token0` provided by the user.

Let further `(minAmount0, minAmount1) = computeMinAmountsForPosition(tickLower, tickUpper, currentSqrtPrice, inputAmount0, inputAmount1, slippageTolerance)`. Once the user has provided the data as described above, the create-position is prepared with the following parameters:

- "poolID": `computePoolID(tokenID0, tokenID1, feeTier)`
- "tickLower": `tickLower`
- "tickUpper": `tickUpper`
- "amount0Desired": `inputAmount0`
- "amount1Desired": `inputAmount1`
- "amount0Min": `minAmount0`
- "amount1Min": `minAmount1`
- "maxTimestampValid": `maxTimestampValid` as described in the global user settings


#### Adding Liquidity to a Position

In this case, the following steps are needed:

1. The user selects one of their positions. Let `inputPositionID` be the position ID of the position selected by the user.
2. Compute the following values:
   - `poolID =  getPoolIDFromPositionID(inputPositionID)`
   - `sqrtCurrentPrice = getCurrentSqrtPrice(poolID, True)`
   - `tickLower = getPosition(inputPositionID).tickLower`
   - `tickUpper = getPosition(inputPositionID).tickUpper`
3. The user chooses `inputAmount0` and `inputAmount1` as described in Step 2 in Case 2 above. Additionally, `minAmount0` and `minAmount1` are computed in the same way. Let further `(minAmount0, minAmount1) = computeMinAmountsForPosition(tickLower, tickUpper, currentSqrtPrice, inputAmount0, inputAmount1, slippageTolerance)`.

Once the user has provided the data as described above, the add-liquidity command is prepared with the following parameters:

- "positionID": `inputPositionID`
- "amount0Desired": `inputAmount0`
- "amount1Desired": `inputAmount1`
- "amount0Min": `minAmount0`
- "amount1Min": `minAmount1`
- "maxTimestampValid": `maxTimestampValid` as described in the global user settings

#### Removing Liquidity from a New Position

1. The user selects one of their positions. Let `inputPositionID` be the position ID of the position selected by the user.
2. Compute the following values:
   - `poolID =  getPoolIDFromPositionID(inputPositionID)`
   - `sqrtCurrentPrice = getCurrentSqrtPrice(poolID, True)`
   - `tickLower = getPosition(inputPositionID).tickLower`
   - `tickUpper = getPosition(inputPositionID).tickUpper`
   - `liquidity = getPosition(inputPositionID).liquidity`
3. The user selects the percentage of the liquidity that should be removed. Let `userInputPercentageLiquidity` be the fraction of liquidity to be removed in parts-per-million, i.e., `0 < userInputPercentageLiquidity <= 10**6`. We then compute the following values and can show the computed amounts to the user.
   - `liquidityToRemove = liquidity * userInputPercentageLiquidity // 10**6`
   - `amount0Position = getAmount0ForLiquidity(currentSqrtPrice, upperSqrtPrice, liquidity)`
   - `amount1Position = getAmount1ForLiquidity(lowerSqrtPrice, currentSqrtPrice, liquidity)`
   - `amount0ToRemove = getAmount0ForLiquidity(currentSqrtPrice, upperSqrtPrice, liquidityToRemove)`
   - `amount1ToRemove = getAmount1ForLiquidity(lowerSqrtPrice, currentSqrtPrice, liquidityToRemove)`
   - `(minAmount0, minAmount1) = computeMinAmountsForPosition(tickLower, tickUpper, currentSqrtPrice, amount0ToRemove, amount1ToRemove, slippageTolerance)`.

Once the user has provided the data as described above, the remove-liquidity command is prepared with the following parameters:

   - "positionID": `inputPositionID`
   - "liquidityToRemove": `liquidityToRemove`
   - "amount0Min": `minAmount0`
   - "amount1Min": `minAmount1`
   - "maxTimestampValid": `maxTimestampValid` as described in the global user settings

### Auxiliary functions

#### computeTickAndPriceRoundedToTick

For a given price as floating point number, this function computes the corresponding tick value as well as the floating point price corresponding to the tick value.

```python
def computeTickAndPriceRoundedToTick(price: float) -> (tickValue: int32, priceRoundedToTick: float):
    sqrtPriceFloat = sqrt(price)
    sqrtPriceQ96 = Q96(sqrtPriceFloat)
    tickValue = priceToTick(sqrtPriceQ96)
    sqrtPriceRoundedQ96 = tickToPrice(tickValue)
    priceRoundedToTick = Q_96_ToFloat(mul_96(sqrtPriceRoundedQ96, sqrtPriceRoundedQ96))
    return (tickValue, priceRoundedToTick)
```

#### computeAmount0ForPosition

For a position with the boundaries given by `tickLower` and `tickUpper`, the current price `currentSqrtPrice` within the range of the position and an amount of `token1` to be added to the position, this function computes the corresponding amount of `token0`.

```python
def computeAmount0ForPosition(tickLower: int32, tickUpper: int32, currentSqrtPrice: Q96, amount1: uint64) -> uint64:
    lowerSqrtPrice = tickToPrice(tickLower)
    upperSqrtPrice = tickToPrice(tickUpper)
    liquidity = getLiquidityForAmount1(lowerSqrtPrice, currentSqrtPrice, amount1)
    return getAmount0ForLiquidity(currentSqrtPrice, upperSqrtPrice, liquidity)
```

#### computeAmount1ForPosition

For a position with the boundaries given by `tickLower` and `tickUpper`, the current price `currentSqrtPrice` within the range of the position and an amount of `token0` to be added to the position, this function computes the corresponding amount of `token1`.

```python
def computeAmount1ForPosition(tickLower: int32, tickUpper: int32, currentSqrtPrice: Q96, amount0: uint64) -> uint64:
    lowerSqrtPrice = tickToPrice(tickLower)
    upperSqrtPrice = tickToPrice(tickUpper)
    liquidity = getLiquidityForAmount0(currentSqrtPrice, upperSqrtPrice, amount0)
    return getAmount1ForLiquidity(lowerSqrtPrice, currentSqrtPrice, liquidity)
```

#### getAmount0ForLiquidity

This function computes the amount of `token0` that correspond to a given amount of liquidity and price boundaries as sqrt prices.
This function is similar to the function [getAmount0ForLiquidity](https://github.com/Uniswap/v3-periphery/blob/b06959dd01f5999aa93e1dc530fe573c7bb295f6/contracts/libraries/LiquidityAmounts.sol#L82) in Uniswap v3.

```python
# see Equation (4) in http://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf
def getAmount0ForLiquidity(lowerSqrtPrice: Q96, upperSqrtPrice: Q96, liquidity: uint64) -> uint64:
    res = muldiv_96(Q96(liquidity), upperSqrtPrice - lowerSqrtPrice, upperSqrtPrice)
    return div_96(res, lowerSqrtPrice)
```

#### getAmount1ForLiquidity

This function computes the amount of `token1` that correspond to a given amount of liquidity and price boundaries as sqrt prices.
This function is similar to the function [getAmount1ForLiquidity](https://github.com/Uniswap/v3-periphery/blob/b06959dd01f5999aa93e1dc530fe573c7bb295f6/contracts/libraries/LiquidityAmounts.sol#L102) in Uniswap v3.

```python
# see Equation (8) in http://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf
def getAmount1ForLiquidity(lowerSqrtPrice: Q96, upperSqrtPrice: Q96, liqudity: uint64) -> uint64:
    return mul_96(Q96(liqudity), upperSqrtPrice - lowerSqrtPrice)
```

#### computeMinAmountsForPosition

For a position with the boundaries given by `tickLower` and `tickUpper`, the current price `currentSqrtPrice` within the range of the position, a slippage tolerance `slippageTolerance` as described above, a desired amount of `token0` to be added to the position and a desired amount of `token1` to be added to the position, this function returns `(minAmount0, minAmount1)` where these are the minimum amounts of tokens that can be used as input parameters to guarantee that the command only succeeds if the price slippage is at most the value given as input.

```python
def computeMinAmountsForPosition(tickLower: int32, tickUpper: int32, currentSqrtPrice: Q96, amount0: uint64, amount1: uint64, slippageTolerance: uint64) -> (uint64, uint64):
    lowerSqrtPrice = tickToPrice(tickLower)
    upperSqrtPrice = tickToPrice(tickUpper)
    slippageFractionFloat = sqrt(1 + slippageTolerance / (10**6))
    slippageFraction = Q96(slippageFractionFloat)

    # If the price decreases, less token1 are required if the amount of token0 stays unchanged.
    # Therefore the lower bound amount1min implies a bound on the price decrease.
    currentSqrtPriceDecreased = div_96(sqrtCurrentPrice, slippageFraction)
    if currentSqrtPriceDecreased <= lowerSqrtPrice:
        # If the decreased price is below the position range, the amount of token1 is 0.
        amount1Min = 0
    elif currentSqrtPriceDecreased >= upperSqrtPrice:
        # If the decreased price is above the position range, the amount of token1 is still the same as without the price change.
        amount1Min = amount1
    else:
        liquidity = getLiquidityForAmount0(currentSqrtPriceDecreased, upperSqrtPrice, amount0)
        amount1Min = getAmount1ForLiquidity(lowerSqrtPrice, currentSqrtPriceDecreased, liquidity)

    # If the price increases, less token0 are required if the amount of token1 stays unchanged.
    # Therefore the lower bound amount0min implies a bound on the price increase.
    currentSqrtPriceIncreased = mul_96(sqrtCurrentPrice, slippageFraction)
    if currentSqrtPriceIncreased >= lowerSqrtPrice:
        # If the increased price is above the position range, the amount of token0 is 0.
        amount0Min = 0
    elif currentSqrtPriceIncreased <= upperSqrtPrice:
        # If the increased price is below the position range, the amount of token0 is still the same as without the price change.
        amount0Min = amount0
    else:
        liquidity = getLiquidityForAmount1(lowerSqrtPrice, currentSqrtPriceIncreased, amount1)
        amount0Min = getAmount0ForLiquidity(currentSqrtPriceIncreased, upperSqrtPrice, liquidity)

    return (amount0Min, amount1Min)
```


[lip-0027]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0027.md
[lip-0051]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0051.md
[lip-0052]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0052.md
[define-dex-module]: https://github.com/LiskHQ/lisk-dex-specs/blob/main/specifications/0001.md
[define-dex-module-constants]: https://github.com/LiskHQ/lisk-dex-specs/blob/main/specifications/0001.md#notation-and-constants
[define-swap-interactions]: https://github.com/LiskHQ/lisk-dex-specs/blob/main/specifications/0003.md
